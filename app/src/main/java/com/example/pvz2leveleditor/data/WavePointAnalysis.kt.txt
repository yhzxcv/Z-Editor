package com.example.pvz2leveleditor.data

object WavePointAnalysis {

    object ExpectationCalculator {
        data class InputEntry(val id: String, val cost: Int, val weight: Double)

        fun calculate(entries: List<InputEntry>, totalPoints: Int): Map<String, Double> {
            if (totalPoints <= 0 || entries.isEmpty()) return entries.associate { it.id to 0.0 }

            val validEntries = entries.filter { it.weight > 0 && it.cost >= 0 }
            if (validEntries.isEmpty()) return emptyMap()

            val safePoints = totalPoints.coerceAtMost(20000)
            val numTypes = validEntries.size
            // exp[僵尸索引][当前点数]
            val exp = Array(numTypes) { DoubleArray(safePoints + 1) { 0.0 } }

            for (p in 1..safePoints) {
                var weightSum = 0.0
                val affordableFlags = BooleanArray(numTypes)

                for (i in 0 until numTypes) {
                    val canAfford = validEntries[i].cost in 1..p
                    affordableFlags[i] = canAfford
                    if (canAfford) weightSum += validEntries[i].weight
                }

                if (weightSum <= 0.0) {
                    for (j in 0 until numTypes) exp[j][p] = exp[j][p-1]
                    continue
                }

                for (j in 0 until numTypes) {
                    var currentExpSum = 0.0
                    for (k in 0 until numTypes) {
                        if (affordableFlags[k]) {
                            val prob = validEntries[k].weight / weightSum
                            val costK = validEntries[k].cost
                            var term = exp[j][p - costK]
                            if (k == j) term += 1.0
                            currentExpSum += prob * term
                        }
                    }
                    exp[j][p] = currentExpSum
                }
            }

            val result = mutableMapOf<String, Double>()
            validEntries.forEachIndexed { index, entry -> result[entry.id] = exp[index][safePoints] }
            entries.forEach { if (!result.containsKey(it.id)) result[it.id] = 0.0 }
            return result
        }
    }

    fun calculateExpectation(
        points: Int,
        parsedData: ParsedLevelData
    ): Map<String, Double> {
        // 1. 负数或零不计算
        if (points <= 0) return emptyMap()

        // 2. 获取僵尸池 (Zombie Pool)
        // 从 WaveManagerModule 里找 DynamicZombies 配置
        val waveModule = parsedData.waveModule
        if (waveModule == null || waveModule.dynamicZombies.isEmpty()) {
            return emptyMap()
        }

        // 通常取第一组配置 (如果有多个分组逻辑需根据 waveIndex 进一步匹配，目前取[0]即可)
        val dynamicGroup = waveModule.dynamicZombies[0]
        val zombiePool = dynamicGroup.zombiePool

        if (zombiePool.isEmpty()) return emptyMap()

        // 3. 准备计算输入数据
        val inputs = zombiePool.map { rtid ->
            // 解析别名 -> 查标准名 -> 查属性
            val alias = RtidParser.parse(rtid)?.alias ?: rtid
            val typeName = ZombiePropertiesRepository.getTypeNameByAlias(alias)
            val stats = ZombiePropertiesRepository.getStats(typeName)

            ExpectationCalculator.InputEntry(
                id = typeName,
                cost = stats.cost,
                weight = stats.weight.toDouble()
            )
        }

        // 4. 调用核心算法
        return ExpectationCalculator.calculate(inputs, points)
    }
}